#!/usr/bin/env python3
"""
Generate code for SqlAlchemy tables from data.

Usage:
  sql_models_from_data.py [options] <tsv>

Arguments:
  tsv:      tsv file (see below)

Required columns in input file (output format of json_to_tabdata):
  (1) table name
  (2) column name
  (3) value (JSON format)

Options:
  --out, -o <FILENAME>  output file (default: stdout)
{common}
"""

from docopt import docopt
from schema import Use, And, Or
import json
import textwrap
import sys
from lib import scripts, snake

def emit_prelude(args):
  args["--out"].write(textwrap.dedent("""\
  #!/usr/bin/env python3
  \"\"\"
  This file was autogenerated, based on the content of file:
  """))
  args["--out"].write(args["<tsv>"])
  args["--out"].write(textwrap.dedent("""\

  Do not edit manually, since any modification could be overwritten.
  \"\"\"

  from sqlalchemy.sql import func
  from sqlalchemy.ext.declarative import declarative_base
  from sqlalchemy import Column, Integer, String, Sequence, \\
                         DateTime, Text, Boolean, Float
  from sqlalchemy_repr import PrettyRepresentableBase

  Base = declarative_base(cls=PrettyRepresentableBase)

  utf8_cs_args = {'mysql_charset': 'utf8', 'mysql_collate': 'utf8_bin'}
  """))

def parse_file(args):
  result = {}
  with open(args["<tsv>"]) as f:
    for line in f:
      line = line.rstrip()
      if line != "###":
        elems = line.split("\t")
        tablename = elems[0]
        colname = elems[1]
        json_data = json.loads(elems[2])
        if tablename not in result:
          result[tablename] = {colname: []}
        if colname not in result[tablename]:
          result[tablename][colname] = []
        result[tablename][colname].append(json_data)
  return result

def emit_tables_code(data, args):
  for tablename in data.keys():
    klassname = "".join(w.title() for w in tablename.split("_"))
    args["--out"].write(f"\nclass {klassname}(Base):\n")
    args["--out"].write(f"  __tablename__ = '{tablename}'\n")
    args["--out"].write("  id = Column(Integer, "+
        f"Sequence('{tablename}_id_seq'), primary_key=True)\n")
    args["--out"].write("  time_updated = Column(DateTime,\n")
    args["--out"].write("    server_default=func.now(), "+
        "onupdate=func.now())\n")
    for colname, coldata in data[tablename].items():
      if all(isinstance(v, bool) for v in coldata):
        args["--out"].write(f"  {colname} = Column(Boolean)\n")
      elif all(isinstance(v, int) for v in coldata):
        args["--out"].write(f"  {colname} = Column(Integer)\n")
      elif all(isinstance(v, float) for v in coldata):
        args["--out"].write(f"  {colname} = Column(Float)\n")
      else:
        lens = [len(str(v)) for v in coldata]
        maxlen = max(lens)
        if maxlen < 32:
          args["--out"].write(f"  {colname} = Column(String(64))\n")
        elif maxlen < 64:
          args["--out"].write(f"  {colname} = Column(String(128))\n")
        elif maxlen < 128:
          args["--out"].write(f"  {colname} = Column(String(256))\n")
        else:
          args["--out"].write(f"  {colname} = Column(Text({maxlen*2}))\n")
    args["--out"].write("  __table_args__ = utf8_cs_args\n")

def main(args):
  emit_prelude(args)
  data = parse_file(args)
  emit_tables_code(data, args)

def validated(args):
  opt_out = Or(And(None, Use(lambda f: sys.stdout)),
                   Use(lambda f: open(f, "w")))
  return scripts.validate(args, {"<tsv>": open, "--out": opt_out})

if "snakemake" in globals():
  args = snake.args(snakemake, input=["<tsv"], output=["--out"])
  main(validated(args))
elif __name__ == "__main__":
  args = docopt(__doc__.format(common=scripts.args_doc), version=0.1)
  main(validated(args))
